import{_ as n,c as a,f as o,a as t,b as l,d as s,o as i,r as p}from"./app-CiE5TDcB.js";const c={},d={href:"https://refactoringguru.cn/design-patterns/proxy",target:"_blank",rel:"noopener noreferrer"};function h(g,e){const r=p("ExternalLinkIcon");return i(),a("div",null,[e[1]||(e[1]=o('<div class="custom-container info"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8h.01"></path><path d="M11 12h1v4h1"></path></g></svg><p class="custom-container-title">《Java 设计模式及实践》 P66 4.2 代理模式</p><p>每当使用 Enterprise 或 Spring bean ，模拟实例和实现 AOP 时，对具有相同接口的另一个对象进行 RMI 或 JNI 调用，或直接/间接使用 <code>java.lang.reflect.Proxy</code> 时，就会涉及一个代理对象。它的目的是为真实对象提供一个代理对象，二者占用的内存一样。在<u>调用前后执行其他操作</u>时，由代理对象代理原对象的工作。</p></div><p>代理对象的作用，简而言之，就是在不改变原有业务逻辑的情况下，在方法执行前后插入一些操作，通常是为了日志记录、事务管理、安全控制等。</p><p>在 Spring 或 Enterprise JavaBean（EJB）中，代理对象通常通过动态代理实现。具体的实现方式可以是：</p><ul><li><ol><li><strong>JDK 动态代理</strong>：如果目标对象实现了接口，Spring 会通过 <code>java.lang.reflect.Proxy</code> 创建代理类。</li></ol></li><li><ol start="2"><li><strong>CGLIB 代理</strong>：如果目标对象没有实现接口，Spring 会通过 CGLIB 库（基于字节码操作）生成目标对象的子类，来实现方法的代理。</li></ol></li></ul><p>代理对象和原对象的内存占用一样，主要是因为代理对象内部持有真实对象的引用，这样它能够通过调用真实对象的方法来完成实际的业务逻辑。</p><p>RMI 或 JNI 调用，代理对象也能被用来在分布式系统中充当客户端与服务器之间的通信桥梁。在这种情况下，代理对象通常会用来隐藏网络通信的复杂性，提供一个本地的接口，客户端调用时看不出远程调用的细节。</p><p>总结一下，代理对象的核心目的就是通过透明地引入额外的操作，来增强或修改目标对象的行为，同时保持原有逻辑的完整性。</p><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>在理想情况下，我们希望将代码直接放入对象的类中，但这并非总是能实现：比如类可能是第三方封闭库的一部分。</p><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',11)),t("p",null,[t("a",d,[e[0]||(e[0]=l("REFACTORING·GURU· 代理模式")),s(r)])])])}const m=n(c,[["render",h],["__file","proxy.html.vue"]]),u=JSON.parse('{"path":"/series/design-patterns/proxy.html","title":"代理/Proxy","lang":"en-US","frontmatter":{"title":"代理/Proxy"},"headers":[{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1739512436000,"updatedTime":1739512436000,"contributors":[{"name":"柒月廿三","email":"lxang723@163.com","commits":1}]},"filePathRelative":"series/design-patterns/proxy.md"}');export{m as comp,u as data};
