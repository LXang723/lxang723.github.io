import{_ as e,c as l,f as p,a as s,b as t,d as i,o as c,r as o}from"./app-DeEWtc_a.js";const r={},u={href:"https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html",target:"_blank",rel:"noopener noreferrer"};function d(k,n){const a=o("ExternalLinkIcon");return c(),l("div",null,[n[1]||(n[1]=p(`<p>Spring 的循环依赖</p><h2 id="什么是循环依赖" tabindex="-1"><a class="header-anchor" href="#什么是循环依赖"><span>什么是循环依赖 ？</span></a></h2><p>循环依赖（Circular Dependency）指的是两个或多个模块或组件相互依赖，导致无法确定加载或初始化的顺序。</p><p><strong>场景：</strong></p><ul><li>类之间的循环依赖：类 A 依赖类 B，类 B 又依赖类 A，导致无法实例化。</li><li>Spring Bean 之间的循环依赖：Bean A 依赖 Bean B，Bean B 又依赖 Bean A，导致 Spring 容器无法初始化。</li><li>模块之间的循环依赖：模块 A 依赖模块 B，模块 B 又依赖模块 A，导致编译或加载失败。</li></ul><p><strong>解决方法：</strong></p><ul><li>依赖倒置：引入抽象层（如接口或抽象类），让模块依赖抽象而非具体实现。</li><li>依赖注入：通过外部容器管理依赖，避免直接依赖。</li><li>重构代码：将共享功能提取到独立模块中，打破循环依赖。</li></ul><h2 id="spring-如何解决循环依赖" tabindex="-1"><a class="header-anchor" href="#spring-如何解决循环依赖"><span>Spring 如何解决循环依赖 ？</span></a></h2><p>Spring 通过 <strong>三级缓存</strong> 和 <strong>提前暴露 Bean</strong> 的机制，解决了单例 Bean 属性注入的循环依赖问题。其核心思想是：</p><ul><li>在 Bean 未完全初始化时，提前暴露其引用。</li><li>通过缓存机制，确保依赖注入的正确性和顺序。</li></ul><p>Spring 通过 <strong>三级缓存</strong> 来管理 Bean 的创建过程，从而解决循环依赖问题。三级缓存分别是：</p><ul><li>一级缓存（Singleton Objects）：存放完全初始化好的 Bean。</li><li>二级缓存（Early Singleton Objects）：存放提前暴露的 Bean（尚未完成属性注入和初始化）。</li><li>三级缓存（Singleton Factories）：存放 Bean 的工厂对象，用于生成提前暴露的 Bean。</li></ul><details class="custom-container details"><summary class="custom-container-title">Spring 中的三级缓存本质上是三个 Map：</summary><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 一级缓存</span></span>
<span class="line"><span class="token doc-comment comment">/** Cache of singleton objects: bean name to bean instance. */</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 二级缓存</span></span>
<span class="line"><span class="token doc-comment comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 三级缓存</span></span>
<span class="line"><span class="token doc-comment comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span>
<span class="line"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><div class="custom-container warning"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="9"></circle><path d="M12 8v4"></path><path d="M12 16h.01"></path></g></svg><p class="custom-container-title">注意</p><p>Spring 解决循环依赖的条件是：</p><ol><li>依赖的 Bean 必须都是单例。</li><li>依赖注入的方式，必须<strong>不全是</strong>构造器注入，且 beanName 字母序在前的不能是构造器注入。</li></ol><p>只有同时满足以上两点才能解决循环依赖的问题。</p></div><h3 id="_1-为什么必须都是单例" tabindex="-1"><a class="header-anchor" href="#_1-为什么必须都是单例"><span>1. 为什么必须都是单例 ？</span></a></h3><p><code>#TODO Bean 的作用域有哪些?</code></p><p>原型（Prototype）Bean：每次请求都会创建一个新的实例，Spring 无法提前暴露未完全初始化的 Bean。</p><h3 id="_2-为什么不能全是构造器注入" tabindex="-1"><a class="header-anchor" href="#_2-为什么不能全是构造器注入"><span>2. 为什么不能全是构造器注入 ？</span></a></h3><p><code>#TODO 注入 Bean（依赖注入）的方式有哪些？</code></p><p>在 Spring 中，<strong>依赖注入的方式</strong> 对解决循环依赖有重要影响。如果依赖注入的方式 <strong>不全是构造器注入</strong>，且 <strong>beanName 字母序在前的 Bean 不能是构造器注入</strong>，Spring 才能通过提前暴露引用的机制解决循环依赖问题。以下是详细解释：</p><p><strong>① 依赖注入的方式</strong></p><p>Spring 支持以下两种依赖注入方式：</p><ol><li><p><strong>构造器注入（Constructor Injection）</strong>：</p><ul><li>通过构造器注入依赖。</li><li>在 Bean 实例化时就必须完成依赖注入。</li><li>无法提前暴露引用，因此无法解决循环依赖。</li></ul></li><li><p><strong>属性注入（Setter Injection 或 Field Injection）</strong>：</p><ul><li>通过 <code>@Autowired</code> 注解注入属性。</li><li>在 Bean 实例化后完成依赖注入。</li><li>可以提前暴露引用，因此可以解决循环依赖。</li></ul></li></ol><p><strong>② 解决循环依赖的条件</strong></p><p>Spring 解决循环依赖的条件是：</p><ol><li><p><strong>依赖注入方式不能全是构造器注入</strong>：</p><ul><li>如果所有依赖都通过构造器注入，Spring 无法提前暴露引用，无法解决循环依赖。</li><li>必须至少有一个依赖是通过属性注入（Setter 或 Field）完成的。</li></ul></li><li><p><strong>beanName 字母序在前的 Bean 不能是构造器注入</strong>：</p><ul><li>Spring 在解决循环依赖时，会按照 beanName 的字母顺序处理 Bean。</li><li>如果字母序在前的 Bean 是通过构造器注入的，Spring 无法提前暴露其引用，导致循环依赖无法解决。</li></ul></li></ol><p><strong>③ 为什么需要这些条件？</strong></p><ul><li><strong>提前暴露引用</strong>：Spring 通过提前暴露未完全初始化的 Bean 引用来解决循环依赖。如果依赖是通过构造器注入的，Bean 在实例化时就必须完成依赖注入，无法提前暴露引用。</li><li><strong>字母序的影响</strong>：Spring 按照 beanName 的字母顺序处理 Bean。如果字母序在前的 Bean 是通过构造器注入的，Spring 会尝试先初始化它，但由于它依赖的 Bean 还未初始化，会导致循环依赖无法解决。</li></ul><p><strong>④ 代码示例</strong></p><p><strong>示例 1：可以解决循环依赖</strong></p><details class="custom-container details"><summary class="custom-container-title">详情</summary><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setB</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><ul><li>A 使用属性注入，B 使用构造器注入。</li><li>Spring 可以提前暴露 A 的引用，解决循环依赖。</li></ul><p><strong>示例 2：无法解决循环依赖</strong></p><details class="custom-container details"><summary class="custom-container-title">详情</summary><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token annotation punctuation">@Component</span></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token annotation punctuation">@Autowired</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setA</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><ul><li>A 使用构造器注入，B 使用属性注入。</li><li>由于 A 的 beanName 字母序在 B 之前，且 A 是构造器注入，Spring 无法提前暴露 A 的引用，导致循环依赖无法解决。</li></ul><p><strong>⑤ 总结</strong></p><ul><li>Spring 解决循环依赖的条件是： <ol><li>依赖注入方式不能全是构造器注入。</li><li>beanName 字母序在前的 Bean 不能是构造器注入。</li></ol></li><li>如果满足以上条件，Spring 可以通过提前暴露引用的机制解决循环依赖问题。</li><li>如果无法满足条件，建议通过 <strong>重构代码</strong> 或 <strong>使用 <code>@Lazy</code> 注解</strong> 来避免循环依赖。</li></ul><hr><p><strong>⑥ 额外建议</strong></p><ul><li>尽量避免循环依赖，因为它会增加代码的复杂性和维护成本。</li><li>如果必须使用循环依赖，优先使用属性注入（Setter 或 Field Injection），并确保字母序在前的 Bean 不是构造器注入。</li><li>使用 <code>@Lazy</code> 注解可以延迟加载依赖，从而解决部分循环依赖问题。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p><p>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</p>`,43)),s("p",null,[s("a",u,[n[0]||(n[0]=t("JavaGuide：Spring常见面试题总结")),i(a)])])])}const g=e(r,[["render",d],["__file","spring-circular-dependency.html.vue"]]),v=JSON.parse('{"path":"/series/tech/framework/spring/spring-circular-dependency.html","title":"循环依赖","lang":"en-US","frontmatter":{"title":"循环依赖"},"headers":[{"level":2,"title":"什么是循环依赖 ？","slug":"什么是循环依赖","link":"#什么是循环依赖","children":[]},{"level":2,"title":"Spring 如何解决循环依赖 ？","slug":"spring-如何解决循环依赖","link":"#spring-如何解决循环依赖","children":[{"level":3,"title":"1. 为什么必须都是单例 ？","slug":"_1-为什么必须都是单例","link":"#_1-为什么必须都是单例","children":[]},{"level":3,"title":"2. 为什么不能全是构造器注入 ？","slug":"_2-为什么不能全是构造器注入","link":"#_2-为什么不能全是构造器注入","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1738460491000,"updatedTime":1738460491000,"contributors":[{"name":"柒月廿三","email":"lxang723@163.com","commits":1}]},"filePathRelative":"series/tech/framework/spring/spring-circular-dependency.md"}');export{g as comp,v as data};
